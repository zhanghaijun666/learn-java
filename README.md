#### 七大设计原则
通过理解七大设计原则,来告诉程序员如何进行面向对象的设计与世界

- 开闭原则:对修改关闭,对扩展开放。一切都是为了保证代码的扩展性和复用性。而开闭原则是基础要求。
- 单一职责原则:单类应该如何定义
- 接口隔离原则:单接口应该如何定义
- 依赖倒置原则:面向接口/抽象编程思维,在方法的返回值、参数类型等都使用接口或者抽象类,而不是使用实现类。
- 里式替换原则:如何去编写继承类的代码,子类不要去覆盖父类已经实现的方法。(抽象模板方法)
- 迪米特法则:最少认知原则,不要和陌生人说话。类与类之间要高内聚,低耦合。项目经理不要直接去访问与他没有直接关系的测试人员。而是调用测试经理的相关功能。
- 合成复用原则:能用组合关系的情况下,不要使用继承关系。就比如说,如果你想拥有某个对象的功能,不要直接继承它,而是将它作为我的成员变量去使用。

#### 二十三种设计模式
- 创建型设计模式:`简单工厂模式`、`工厂方法模式`、`抽象工厂模式`、`单例模式`、`原型模式`、`构建者模式`。
- 行为型设计模式:`责任链模式`、`观察者模式`、`门面模式`、`策略模式`、`适配器模式`等
- 结构型设计模式:`组合模式`、`代理模式`、`装饰模式`等

####  手写spring IOC



####  手写spring AOP



#### `JDK动态代理`和`Cglib动态代理`的区别:
1. `JDK动态代理`是Java自带的,`Cglib动态代理`是第三方jar包提供的。
2. `JDK动态代理`是针对【拥有接口的目标类】进行动态代理的,而`Cglib动态代理`是非final类都可以进行动态代理。但是Spring优先使用`JDK动态代理`。
3. `JDK动态代理`实现的逻辑是目标类和代理类都实现同一个接口,目标类和代理类是平级的。而`Cglib动态代理`实现的逻辑是给目标类生个孩子(子类,也就是代理类),标类和代理类是父子继承关系。
4. `JDK动态代理`在早期的JDK1.6左右性能比cglib差,但是在JDK1.8以后`Cglib动态代理`和`JDK动态代理`性能基本上差不多。反而`JDK动态代理`性能更加的优越。
